var documenterSearchIndex = {"docs":
[{"location":"man/workflow_tips/#Workflow-tips","page":"Workflow tips","title":"Workflow tips","text":"","category":"section"},{"location":"man/workflow_tips/#Starting-the-workflow","page":"Workflow tips","title":"Starting the workflow","text":"","category":"section"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"Usually you will start by having a Tables.jl implementation loaded with the data you want to work with, so your next step could be to use a non-mutating Cleaner function to start your Cleaner workflow.","category":"page"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"julia> using DataFrames: DataFrame\n\njulia> using Cleaner\n\njulia> df = DataFrame(\" Some bad Name\" => [missing, missing, missing], \"Another_weird name \" => [1, \"x\", 3])\n3×2 DataFrame\n Row │  Some bad Name  Another_weird name\n     │ Missing         Any\n─────┼─────────────────────────────────────\n   1 │        missing  1\n   2 │        missing  x\n   3 │        missing  3\n\njulia> ct = polish_names(df)\n┌───────────────┬────────────────────┐\n│ some_bad_name │ another_weird_name │\n│       Missing │                Any │\n├───────────────┼────────────────────┤\n│       missing │                  1 │\n│       missing │                  x │\n│       missing │                  3 │\n└───────────────┴────────────────────┘\n\n","category":"page"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"After that, you can decide whether to continue using non-mutating functions or start using mutating ones.","category":"page"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"julia> ct |> compact_columns |> reinfer_schema\n┌────────────────────┐\n│ another_weird_name │\n│   U{Int64, String} │\n├────────────────────┤\n│                  1 │\n│                  x │\n│                  3 │\n└────────────────────┘\n\n\njulia> ct\n┌───────────────┬────────────────────┐\n│ some_bad_name │ another_weird_name │\n│       Missing │                Any │\n├───────────────┼────────────────────┤\n│       missing │                  1 │\n│       missing │                  x │\n│       missing │                  3 │\n└───────────────┴────────────────────┘\n\n\njulia> ct |> compact_columns! |> reinfer_schema!\n┌────────────────────┐\n│ another_weird_name │\n│   U{Int64, String} │\n├────────────────────┤\n│                  1 │\n│                  x │\n│                  3 │\n└────────────────────┘\n\n\njulia> ct\n┌────────────────────┐\n│ another_weird_name │\n│   U{Int64, String} │\n├────────────────────┤\n│                  1 │\n│                  x │\n│                  3 │\n└────────────────────┘\n\n","category":"page"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"Depending on what you are trying to do, one could be a better option than the other. For example, if you need to keep copies of the data in order to do different transformations between copies, using non-mutating functions would be a better fit, whereas if you just want to do a series of linear transformations on your data and continue processing it after finishing the cleaning, using mutating functions would a better option.","category":"page"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"You could also mix and match mutating and non-mutating Cleaner functions to better fit your needs, as all non-mutating Cleaner functions work on any Tables.jl implementation and return a CleanTable, while all mutating Cleaner functions work on a CleanTable and return a CleanTable which also is a Tables.jl implementation.","category":"page"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"There is also the option to build a CleanTable from any Tables.jl implementation to start a your workflow by mutating even the data stored in the original table, as the CleanTable constructor has a keyword argument copycols that can be set to false to use the original columns directly at your own risk.","category":"page"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"julia> ct = CleanTable(df; copycols=false) |> polish_names! |> compact_columns!\n┌────────────────────┐\n│ another_weird_name │\n│                Any │\n├────────────────────┤\n│                  1 │\n│                  x │\n│                  3 │\n└────────────────────┘\n\n\njulia> ct.another_weird_name[2] = 4\n4\n\njulia> ct\n┌────────────────────┐\n│ another_weird_name │\n│                Any │\n├────────────────────┤\n│                  1 │\n│                  4 │\n│                  3 │\n└────────────────────┘\n\n\njulia> df\n3×2 DataFrame\n Row │  Some bad Name  Another_weird name\n     │ Missing         Any\n─────┼─────────────────────────────────────\n   1 │        missing  1\n   2 │        missing  4\n   3 │        missing  3\n","category":"page"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"The complete oposite approach would be to use a function from the ROT (returning original type) variants (e.g. polish_names_ROT) that take as input any table, does it's transformation on a copy of it and then returns a new table of the same type of the source table.","category":"page"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"julia> df |> polish_names_ROT\n3×2 DataFrame\n Row │ some_bad_name  another_weird_name\n     │ Missing        Any\n─────┼───────────────────────────────────\n   1 │       missing  1\n   2 │       missing  4\n   3 │       missing  3\n","category":"page"},{"location":"man/workflow_tips/#Looking-for-performance","page":"Workflow tips","title":"Looking for performance","text":"","category":"section"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"When trying to avoid most of the extra allocations while working with Cleaner, you should start by creating a CleanTable specifying copycols=false to use the original columns directly on the new CleanTable instead of having a non-mutating Cleaner function making copies of them to use on the CleanTable it builds first.","category":"page"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"julia> nt = (A = [missing, missing, missing], B = [4, 'x', 6])\n(A = [missing, missing, missing], B = Any[4, 'x', 6])\n\njulia> ct = CleanTable(nt; copycols=false)\n┌─────────┬─────┐\n│       A │   B │\n│ Missing │ Any │\n├─────────┼─────┤\n│ missing │   4 │\n│ missing │   x │\n│ missing │   6 │\n└─────────┴─────┘\n\n","category":"page"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"Now that you have a CleanTable you should continue by using Cleaner mutating functions, as they will modify the same CleanTable passed as input in place avoiding having to allocate new CleanTables while also avoiding copying the underlying columns data.","category":"page"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"julia> compact_columns!(ct)\n┌─────┐\n│   B │\n│ Any │\n├─────┤\n│   4 │\n│   x │\n│   6 │\n└─────┘\n\n\njulia> row_as_names!(ct, 2)\n┌─────┐\n│   x │\n│ Any │\n├─────┤\n│   6 │\n└─────┘\n\n\njulia> ct\n┌─────┐\n│   x │\n│ Any │\n├─────┤\n│   6 │\n└─────┘\n\n\njulia> nt\n(A = [missing, missing, missing], B = Any[6])\n","category":"page"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"warning: Warning\nNote that when using the original columns to build a CleanTable and using mutating functions in it, the changes also happen on the source potentially corrupting it.If you do need to use the original source after applying mutating Cleaner functions, you can always just use a non-mutating  Cleaner function first to have it create a CleanTable with copied columns first and do its transformation on it and then  continue by using mutating Cleaner functions for performance.","category":"page"},{"location":"man/workflow_tips/#Looking-for-convenience","page":"Workflow tips","title":"Looking for convenience","text":"","category":"section"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"If you just want to apply a Cleaner function or two on your original table, probably you also want to have the result be of the original table type. For this cases we have the convinient ROT function variants, that will keep the original columns intact by applying the transformation on a new CleanTable with copied columns and return a new table based on the result but having it be of the original source type.","category":"page"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"julia> df = DataFrame(\"A\" => [missing, missing, missing], \"B\" => [4, 'x', 6])\n3×2 DataFrame\n Row │ A        B\n     │ Missing  Any\n─────┼──────────────\n   1 │ missing  4\n   2 │ missing  x\n   3 │ missing  6\n\njulia> df2 = compact_columns_ROT(df)\n3×1 DataFrame\n Row │ B\n     │ Any\n─────┼─────\n   1 │ 4\n   2 │ x\n   3 │ 6\n\njulia> df3 = row_as_names_ROT(df2, 2)\n1×1 DataFrame\n Row │ x\n     │ Any\n─────┼─────\n   1 │ 6\n","category":"page"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"Its not recommended to use more than 2 ROT functions on a workflow, as they are the least performant and most allocating function variants. For each time a ROT function is called, it first is creating a CleanTable with copied columns to work with, then applying the desired transformation and then creating a new table of the original source type which commonly copies columns too.","category":"page"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"This ends up allocating a new CleanTable, copying columns, allocating another table of the original source type and copying columns for it to use too for every time a ROT function is used, which when working with bigger tables can become slow and trigger a lot more times the garbage collector as compared by using an alternative workflow.","category":"page"},{"location":"man/workflow_tips/#Final-touches","page":"Workflow tips","title":"Final touches","text":"","category":"section"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"After using all the CleanTable functions you needed, you probably want to have the result be another table type to continue your workflow. For this cases, you can try calling the constructor of your desired table type to try and build a new table based on the output or, if you are not sure if your desired table type has a constructor that works with other table implementations, you can use the materializer function from Tables.jl we conveniently export for you.","category":"page"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"julia> df = DataFrame(\"A\" => [missing, missing, missing], \"B\" => [4, 'x', 6])\n3×2 DataFrame\n Row │ A        B\n     │ Missing  Any\n─────┼──────────────\n   1 │ missing  4\n   2 │ missing  x\n   3 │ missing  6\n\njulia> ct = compact_columns(df);\n\njulia> row_as_names!(ct, 2);\n\njulia> DataFrame(ct)\n1×1 DataFrame\n Row │ x\n     │ Any\n─────┼─────\n   1 │ 6\n\njulia> materializer(df)(ct)\n1×1 DataFrame\n Row │ x\n     │ Any\n─────┼─────\n   1 │ 6\n","category":"page"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"If you are looking to get the most performance, some table types also let you call their constructor having it use the original columns so this way you could avoid some extra allocations.","category":"page"},{"location":"man/workflow_tips/","page":"Workflow tips","title":"Workflow tips","text":"julia> df2 = DataFrame(ct; copycols=false)\n1×1 DataFrame\n Row │ x\n     │ Any\n─────┼─────\n   1 │ 6\n\njulia> df2.x[1] = 3\n3\n\njulia> df2\n1×1 DataFrame\n Row │ x\n     │ Any\n─────┼─────\n   1 │ 3\n\njulia> ct\n┌─────┐\n│   x │\n│ Any │\n├─────┤\n│   3 │\n└─────┘\n\n","category":"page"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"CurrentModule = Cleaner","category":"page"},{"location":"lib/functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"lib/functions/#Multi-threading-support","page":"Functions","title":"Multi-threading support","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"The following functions will try to use multiple threads if possible when there are at least 2 columns and 1 million rows:","category":"page"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"CleanTable constructor when copycols=true\nAll compact functions\ndelete_const_columns, delete_const_columns! and delete_const_columns_ROT\nreinfer_schema, reinfer_schema! andreinfer_schema_ROT\nget_all_repeated","category":"page"},{"location":"lib/functions/#Index","page":"Functions","title":"Index","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"lib/functions/#Summarize-information","page":"Functions","title":"Summarize information","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"size\nget_all_repeated","category":"page"},{"location":"lib/functions/#Cleaner.size","page":"Functions","title":"Cleaner.size","text":"size(table::CleanTable)\n\nReturns a tuple containing the number of rows and columns of the given CleanTable.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.get_all_repeated","page":"Functions","title":"Cleaner.get_all_repeated","text":"get_all_repeated(table, columns::Vector{Symbol})\n\nReturns a CleanTable with row indexes containing only the selected columns and keeping only the rows that were repeated.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Working-with-column-names","page":"Functions","title":"Working with column names","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"rename\nrename!\nrename_ROT\ngenerate_polished_names\npolish_names\npolish_names!\npolish_names_ROT\nrow_as_names\nrow_as_names!\nrow_as_names_ROT","category":"page"},{"location":"lib/functions/#Cleaner.rename","page":"Functions","title":"Cleaner.rename","text":"rename(table, names::Vector{Symbol})\n\nCreates a CleanTable with copied columns and changes its column names to be names.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.rename!","page":"Functions","title":"Cleaner.rename!","text":"rename!(ct::CleanTable, names::Vector{Symbol})\n\nChanges in-place the column names of a CleanTable to be names.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.rename_ROT","page":"Functions","title":"Cleaner.rename_ROT","text":"rename_ROT(table, names::Vector{Symbol})\n\nReturns a new table of the original table type where its column names have been changed to be names.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.generate_polished_names","page":"Functions","title":"Cleaner.generate_polished_names","text":"generate_polished_names(names; style::Symbol=:snake_case)\n\nReturn a vector of symbols containing new names that are unique and formated using the style selected.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.polish_names","page":"Functions","title":"Cleaner.polish_names","text":"polish_names(table; style=:snake_case)\n\nCreate and return a CleanTable with copied columns having column names replaced to be unique and formated using the style selected.\n\nStyles\n\nsnake_case\ncamelCase\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.polish_names!","page":"Functions","title":"Cleaner.polish_names!","text":"polish_names!(table::CleanTable; style::Symbol=:snake_case)\n\nReturn a CleanTable where column names have been replaced to be unique and formated using the style selected.\n\nStyles\n\nsnake_case\ncamelCase\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.polish_names_ROT","page":"Functions","title":"Cleaner.polish_names_ROT","text":"polish_names_ROT(table; style::Symbol=:snake_case)\n\nReturns a new table of the original table type where column names have been replaced to be unique and formated using the style selected.\n\nStyles\n\nsnake_case\ncamelCase\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.row_as_names","page":"Functions","title":"Cleaner.row_as_names","text":"row_as_names(table, i::Int; remove::Bool=true)\n\nCreates a CleanTable with copied columns and renames the table using row i as new names and removes in-place all the rows above row i if remove=true.\n\nDefault behavior is to remove rows above row i.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.row_as_names!","page":"Functions","title":"Cleaner.row_as_names!","text":"row_as_names!(table::CleanTable, i::Int; remove::Bool=true)\n\nRenames the table using row i as new names and removes in-place all the rows above row i if remove=true.\n\nDefault behavior is to remove rows above row i.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.row_as_names_ROT","page":"Functions","title":"Cleaner.row_as_names_ROT","text":"row_as_names_ROT(table, i::Int; remove::Bool=true)\n\nReturns a new table of the original table type that has been renamed using row i as new names and removes in-place all the rows above row i if remove=true.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Row/Column-removal","page":"Functions","title":"Row/Column removal","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"compact_columns\ncompact_columns!\ncompact_columns_ROT\ncompact_rows\ncompact_rows!\ncompact_rows_ROT\ncompact_table\ncompact_table!\ncompact_table_ROT\ndelete_const_columns\ndelete_const_columns!\ndelete_const_columns_ROT\ndrop_missing\ndrop_missing!\ndrop_missing_ROT","category":"page"},{"location":"lib/functions/#Cleaner.compact_columns","page":"Functions","title":"Cleaner.compact_columns","text":"compact_columns(table; empty_values::Vector=[])\n\nCreates a CleanTable with copied columns and removes from it all columns filled entirely by missing and empty_values.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.compact_columns!","page":"Functions","title":"Cleaner.compact_columns!","text":"compact_columns!(table::CleanTable; empty_values::Vector=[])\n\nRemoves in-place from a CleanTable all columns filled entirely by missing and empty_values.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.compact_columns_ROT","page":"Functions","title":"Cleaner.compact_columns_ROT","text":"compact_columns_ROT(table; empty_values::Vector=[])\n\nReturns a new table of the original table type where all columns filled entirely by missing and empty_values have been removed.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.compact_rows","page":"Functions","title":"Cleaner.compact_rows","text":"compact_rows(table; empty_values::Vector=[])\n\nCreates a CleanTable with copied columns and removes from it all rows filled entirely by missing and empty_values.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.compact_rows!","page":"Functions","title":"Cleaner.compact_rows!","text":"compact_rows!(table::CleanTable; empty_values::Vector=[])\n\nRemoves in-place from a CleanTable all rows filled entirely by missing and empty_values.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.compact_rows_ROT","page":"Functions","title":"Cleaner.compact_rows_ROT","text":"compact_rows_ROT(table; empty_values::Vector=[])\n\nReturns a new table of the original table type where all rows filled entirely by missing and empty_values have been removed.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.compact_table","page":"Functions","title":"Cleaner.compact_table","text":"compact_table(table; empty_values::Vector=[])\n\nCreates a CleanTable with copied columns and removes from it all rows and columns filled entirely by missing and empty_values.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.compact_table!","page":"Functions","title":"Cleaner.compact_table!","text":"compact_table!(table::CleanTable; empty_values::Vector=[])\n\nRemoves in-place from a CleanTable all rows and columns filled entirely by missing and empty_values.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.compact_table_ROT","page":"Functions","title":"Cleaner.compact_table_ROT","text":"compact_table_ROT(table; empty_values::Vector=[])\n\nReturns a new table of the original table type where all rows and columns filled entirely by missing and empty_values have been removed.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.delete_const_columns","page":"Functions","title":"Cleaner.delete_const_columns","text":"delete_const_columns(table)\n\nCreates a CleanTable with copied columns and removes each column filled with just a constant value.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.delete_const_columns!","page":"Functions","title":"Cleaner.delete_const_columns!","text":"delete_const_columns!(table::CleanTable)\n\nRemoves in-place from a CleanTable each column filled with just a constant value.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.delete_const_columns_ROT","page":"Functions","title":"Cleaner.delete_const_columns_ROT","text":"delete_const_columns_ROT(table)\n\nReturns a new table of the original table type where all columns filled with just a constant value have been removed.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.drop_missing","page":"Functions","title":"Cleaner.drop_missing","text":"drop_missing(table; missing_values::Vector=[])\n\nCreates a CleanTable with copied columns and removes from it all rows where missing or missing_values have been found.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.drop_missing!","page":"Functions","title":"Cleaner.drop_missing!","text":"drop_missing!(table::CleanTable; missing_values::Vector=[])\n\nRemoves in-place from a CleanTable all rows where missing or missing_values have been found.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.drop_missing_ROT","page":"Functions","title":"Cleaner.drop_missing_ROT","text":"drop_missing_ROT(table; missing_values::Vector=[])\n\nReturns a new table of the original table type where all rows where missing or missing_values have been found were removed.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Modifiying-table-schema","page":"Functions","title":"Modifiying table schema","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"reinfer_schema\nreinfer_schema!\nreinfer_schema_ROT\nadd_index\nadd_index!\nadd_index_ROT","category":"page"},{"location":"lib/functions/#Cleaner.reinfer_schema","page":"Functions","title":"Cleaner.reinfer_schema","text":"reinfer_schema(table; max_types::Int=3)\n\nCreates a CleanTable with copied columns and tries to minimize the amount of element types for each column without making the column type Any.\n\nFor this, will try to make the column of type Union with up to maxtypes and internally use `Base.promotetypejoin` on all numeric types. If not possible, leaves the column as-is.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.reinfer_schema!","page":"Functions","title":"Cleaner.reinfer_schema!","text":"reinfer_schema!(table::CleanTable; max_types::Int=3)\n\nTries to minimize the amount of element types for each column without making the column type Any.\n\nFor this, will try to make the column of type Union with up to max_types and internally use Base.promote_typejoin on all numeric types. If not possible, leaves the column as-is.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.reinfer_schema_ROT","page":"Functions","title":"Cleaner.reinfer_schema_ROT","text":"reinfer_schema_ROT(table; max_types::Int=3)\n\nReturns a new table of the original table type where it has been tried to minimize the amount of element types for each column without making the column type Any.\n\nFor this, will try to make the column of type Union with up to maxtypes and internally use `Base.promotetypejoin` on all numeric types. If not possible, leaves the column as-is.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.add_index","page":"Functions","title":"Cleaner.add_index","text":"add_index(table)\n\nCreates a CleanTable with copied columns and adds to it a new column being the row index for the table passed.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.add_index!","page":"Functions","title":"Cleaner.add_index!","text":"add_index!(table::CleanTable)\n\nAdds in-place a column being the row index for the CleanTable table.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.add_index_ROT","page":"Functions","title":"Cleaner.add_index_ROT","text":"add_index_ROT(table)\n\nReturns a new table of the original table type where a new column being the row index for the table passed have been added.\n\n\n\n\n\n","category":"function"},{"location":"man/better_schema/#For-a-better-schema","page":"For a better schema","title":"For a better schema","text":"","category":"section"},{"location":"man/better_schema/#Getting-row-numbers","page":"For a better schema","title":"Getting row numbers","text":"","category":"section"},{"location":"man/better_schema/","page":"For a better schema","title":"For a better schema","text":"TODO","category":"page"},{"location":"man/better_schema/#Any-type-would-be-better-than-type-Any","page":"For a better schema","title":"Any type would be better than type Any","text":"","category":"section"},{"location":"man/better_schema/","page":"For a better schema","title":"For a better schema","text":"If you have worked with data in Julia before, you might have ended up with a column of element type Any more than once. This usually happens when your column has a mix of different types that can't be promoted or converted to one and other.","category":"page"},{"location":"man/better_schema/","page":"For a better schema","title":"For a better schema","text":"Now, the main problem is that element type Any doesn't gives us any relevant information about what is being stored in our column.","category":"page"},{"location":"man/better_schema/","page":"For a better schema","title":"For a better schema","text":"julia> [1, 2.0]\n2-element Vector{Float64}:\n 1.0\n 2.0\n\njulia> [\"1\", 2.0]\n2-element Vector{Any}:\n  \"1\"\n 2.0\n","category":"page"},{"location":"man/better_schema/","page":"For a better schema","title":"For a better schema","text":"To solve this problem we have the reinfer_schema, reinfer_schema! and reinfer_schema_ROT functions that will try to make the column of type Union with, by default, up to 3 types stored in Union while also internally using Base.promote_typejoin on numeric types to reduce the final amount of numeric types.","category":"page"},{"location":"man/better_schema/","page":"For a better schema","title":"For a better schema","text":"The optional keyword argument max_types can be used to change the maximum amount of types in Union as, if there would be more than max_types on the final Union, this functions just will give up and let the column stay with element type Any.","category":"page"},{"location":"man/better_schema/","page":"For a better schema","title":"For a better schema","text":"julia> ct = CleanTable([:A, :B, :C], [[1, 2, 3, 4], [5, missing, \"z\", 2.0], [\"6\", \"7\", \"8\", \"9\"]])\n┌─────┬─────────┬─────┐\n│   A │       B │   C │\n│ Any │     Any │ Any │\n├─────┼─────────┼─────┤\n│   1 │       5 │   6 │\n│   2 │ missing │   7 │\n│   3 │       z │   8 │\n│   4 │     2.0 │   9 │\n└─────┴─────────┴─────┘\n\n\njulia> reinfer_schema(ct)\n┌───────┬──────────────────┬────────┐\n│     A │                B │      C │\n│ Int64 │ U{Real, String}? │ String │\n├───────┼──────────────────┼────────┤\n│     1 │                5 │      6 │\n│     2 │          missing │      7 │\n│     3 │                z │      8 │\n│     4 │              2.0 │      9 │\n└───────┴──────────────────┴────────┘\n\n\njulia> reinfer_schema(ct; max_types=2)\n┌───────┬─────────┬────────┐\n│     A │       B │      C │\n│ Int64 │     Any │ String │\n├───────┼─────────┼────────┤\n│     1 │       5 │      6 │\n│     2 │ missing │      7 │\n│     3 │       z │      8 │\n│     4 │     2.0 │      9 │\n└───────┴─────────┴────────┘\n\n","category":"page"},{"location":"man/first_steps/#First-steps","page":"First steps","title":"First steps","text":"","category":"section"},{"location":"man/first_steps/#Installation","page":"First steps","title":"Installation","text":"","category":"section"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"Installing the latest stable version of Cleaner is as simple as using:","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"import Pkg\nPkg.add(\"Cleaner\")","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"After installation has finished, you just need to call using Cleaner to get all Cleaner functionalities in your current namespace.","category":"page"},{"location":"man/first_steps/#About-the-CleanTable-type","page":"First steps","title":"About the CleanTable type","text":"","category":"section"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"A CleanTable is meant to represent data in a tabular format, being column based by design, while also being the type where all Cleaner functions do their work.","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"It implements the Tables.jl interface and the constructor can create a CleanTable from any Tables.jl implementation.","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"julia> using DataFrames\n\njulia> df = DataFrame(A = Any[1, 2, 3, 4], B = Any[\"M\", \"F\", \"F\", \"M\"])\n4×2 DataFrame\n Row │ A    B\n     │ Any  Any\n─────┼──────────\n   1 │ 1    M\n   2 │ 2    F\n   3 │ 3    F\n   4 │ 4    M\n\njulia> using Cleaner\n\njulia> ct = CleanTable(df)\n┌─────┬─────┐\n│   A │   B │\n│ Any │ Any │\n├─────┼─────┤\n│   1 │   M │\n│   2 │   F │\n│   3 │   F │\n│   4 │   M │\n└─────┴─────┘\n\n","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"If the original Tables.jl implementation (source) you were using supports constructing the source type from any Tables.jl implementation, getting back to using an object of your source type is as easy as calling its constructor after you have finished working with Cleaner.","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"julia> reinfer_schema!(ct)\n┌───────┬────────┐\n│     A │      B │\n│ Int64 │ String │\n├───────┼────────┤\n│     1 │      M │\n│     2 │      F │\n│     3 │      F │\n│     4 │      M │\n└───────┴────────┘\n\n\njulia> DataFrame(ct)\n4×2 DataFrame\n Row │ A      B\n     │ Int64  String\n─────┼───────────────\n   1 │     1  M\n   2 │     2  F\n   3 │     3  F\n   4 │     4  M\n","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"All Cleaner functions support piping too so the code above could be rewritten as this:","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"julia> df |> CleanTable |> reinfer_schema! |> DataFrame\n4×2 DataFrame\n Row │ A      B\n     │ Int64  String\n─────┼───────────────\n   1 │     1  M\n   2 │     2  F\n   3 │     3  F\n   4 │     4  M\n","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"By default the CleanTable constructor when called with a table as only argument will copy the columns instead of using directly the source columns. This behavior can be overwritten by explicitly passing the copycols=false keyword argument.","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"julia> ct = CleanTable(df)\n┌─────┬─────┐\n│   A │   B │\n│ Any │ Any │\n├─────┼─────┤\n│   1 │   M │\n│   2 │   F │\n│   3 │   F │\n│   4 │   M │\n└─────┴─────┘\n\n\njulia> ct.A[1] = 5\n5\n\njulia> ct\n┌─────┬─────┐\n│   A │   B │\n│ Any │ Any │\n├─────┼─────┤\n│   5 │   M │\n│   2 │   F │\n│   3 │   F │\n│   4 │   M │\n└─────┴─────┘\n\n\njulia> df\n4×2 DataFrame\n Row │ A    B\n     │ Any  Any\n─────┼──────────\n   1 │ 1    M\n   2 │ 2    F\n   3 │ 3    F\n   4 │ 4    M\n\njulia> ct = CleanTable(df; copycols=false)\n┌─────┬─────┐\n│   A │   B │\n│ Any │ Any │\n├─────┼─────┤\n│   1 │   M │\n│   2 │   F │\n│   3 │   F │\n│   4 │   M │\n└─────┴─────┘\n\n\njulia> ct.A[1] = 5;\n\njulia> ct\n┌─────┬─────┐\n│   A │   B │\n│ Any │ Any │\n├─────┼─────┤\n│   5 │   M │\n│   2 │   F │\n│   3 │   F │\n│   4 │   M │\n└─────┴─────┘\n\n\njulia> df\n4×2 DataFrame\n Row │ A    B\n     │ Any  Any\n─────┼──────────\n   1 │ 5    M\n   2 │ 2    F\n   3 │ 3    F\n   4 │ 4    M\n","category":"page"},{"location":"man/first_steps/#Accessing-columns","page":"First steps","title":"Accessing columns","text":"","category":"section"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"If you want to access an specific column, CleanTable supports access by column index and column name.","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"julia> ct = CleanTable([:A, :B], [[1, 2, 3, 4], [\"M\", \"F\", \"F\", \"M\"]])\n┌───────┬────────┐\n│     A │      B │\n│ Int64 │ String │\n├───────┼────────┤\n│     1 │      M │\n│     2 │      F │\n│     3 │      F │\n│     4 │      M │\n└───────┴────────┘\n\n\njulia> ct.A\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> ct[1]\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"As the result of accessing a column in a CleanTable is the column itself, if you want to reasign values in a column you can just modify the accessed result.","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"E.g:","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"julia> ct.A = [5, 6, 7, 8]\n4-element Vector{Int64}:\n 5\n 6\n 7\n 8\n\njulia> ct\n┌───────┬────────┐\n│     A │      B │\n│ Int64 │ String │\n├───────┼────────┤\n│     5 │      M │\n│     6 │      F │\n│     7 │      F │\n│     8 │      M │\n└───────┴────────┘\n\n","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"warning: Warning\nAdding/removing rows or columns without using Cleaner.jl  functions is not supported and heavily discouraged. Please refer to other packages such as  DataFrames.jl for those needs.","category":"page"},{"location":"man/name_changing/#A-name-changing-help","page":"A name-changing help","title":"A name-changing help","text":"","category":"section"},{"location":"man/name_changing/#Column-names-polishing","page":"A name-changing help","title":"Column names polishing","text":"","category":"section"},{"location":"man/name_changing/","page":"A name-changing help","title":"A name-changing help","text":"Having repated column names, names with spaces in them, names where spaces are padding the beginning or the end, names with inconsistent formating, etc can certainly become a trouble when trying to reference a certain column during your workflow.","category":"page"},{"location":"man/name_changing/","page":"A name-changing help","title":"A name-changing help","text":"To tackle this problems directly, we have the functions polish_names, polish_names! and polish_names_ROT used as follows:","category":"page"},{"location":"man/name_changing/","page":"A name-changing help","title":"A name-changing help","text":"julia> using Cleaner\n\njulia> ct = CleanTable([Symbol(\" Horrible name 1\"), Symbol(\"another_bad Name  \")], [[1], [2]])\n┌──────────────────┬────────────────────┐\n│  Horrible name 1 │ another_bad Name   │\n│            Int64 │              Int64 │\n├──────────────────┼────────────────────┤\n│                1 │                  2 │\n└──────────────────┴────────────────────┘\n\n\njulia> polish_names(ct)\n┌─────────────────┬──────────────────┐\n│ horrible_name_1 │ another_bad_name │\n│           Int64 │            Int64 │\n├─────────────────┼──────────────────┤\n│               1 │                2 │\n└─────────────────┴──────────────────┘\n\n\njulia> polish_names(ct; style=:camelCase)\n┌───────────────┬────────────────┐\n│ horribleName1 │ anotherBadName │\n│         Int64 │          Int64 │\n├───────────────┼────────────────┤\n│             1 │              2 │\n└───────────────┴────────────────┘\n\n","category":"page"},{"location":"man/name_changing/","page":"A name-changing help","title":"A name-changing help","text":"note: Note\nCurrently the only available styles are :snake_case and :camelCase.  The default style is :snake_case.","category":"page"},{"location":"man/name_changing/","page":"A name-changing help","title":"A name-changing help","text":"Internally polish_names, polish_names! and polish_names_ROT all call the generate_polished_names function, so if you just need to generate better names for your table, you could call it as follows and manually rename your table.","category":"page"},{"location":"man/name_changing/","page":"A name-changing help","title":"A name-changing help","text":"julia> generate_polished_names([\"  _aName with_lotsOfProblems\", \"  _aName with_lotsOfProblems\"])\n2-element Vector{Symbol}:\n :a_name_with_lots_of_problems\n :a_name_with_lots_of_problems_1\n\njulia> generate_polished_names([\"  _aName with_lotsOfProblems\", \"  _aName with_lotsOfProblems\"]; style=:camelCase)\n2-element Vector{Symbol}:\n :aNameWithLotsOfProblems\n :aNameWithLotsOfProblems_1\n","category":"page"},{"location":"man/name_changing/","page":"A name-changing help","title":"A name-changing help","text":"If all you want is to change the column names to be your desired ones, you can always use the rename, rename! and rename_ROT functions.","category":"page"},{"location":"man/name_changing/","page":"A name-changing help","title":"A name-changing help","text":"julia> rename(ct, [:A, :B])\n┌───────┬───────┐\n│     A │     B │\n│ Int64 │ Int64 │\n├───────┼───────┤\n│     1 │     2 │\n└───────┴───────┘\n\n","category":"page"},{"location":"man/name_changing/#Making-a-row-be-the-column-names","page":"A name-changing help","title":"Making a row be the column names","text":"","category":"section"},{"location":"man/name_changing/","page":"A name-changing help","title":"A name-changing help","text":"When working with messy data you might end up having the row names being the second or third row of the table you have loaded. For this cases you can use the row_as_names, row_as_names! and row_as_names_ROT functions.","category":"page"},{"location":"man/name_changing/","page":"A name-changing help","title":"A name-changing help","text":"By default, row_as_names, row_as_names! and row_as_names_ROT will remove all rows above the index passed, but this behavior can be overwritten by passing the optional keyword argument remove=false.","category":"page"},{"location":"man/name_changing/","page":"A name-changing help","title":"A name-changing help","text":"julia> ct = CleanTable([Symbol(\" \"), Symbol(\" \")], [[\" \", \"A\", 1], [\" \", \"B\", 2]])\n┌─────┬─────┐\n│     │     │\n│ Any │ Any │\n├─────┼─────┤\n│     │     │\n│   A │   A │\n│   1 │   1 │\n└─────┴─────┘\n\n\njulia> row_as_names(ct, 2)\n┌─────┬─────┐\n│   A │   B │\n│ Any │ Any │\n├─────┼─────┤\n│   1 │   2 │\n└─────┴─────┘\n\n\njulia> row_as_names(ct, 2; remove=false)\n┌─────┬─────┐\n│   A │   B │\n│ Any │ Any │\n├─────┼─────┤\n│     │     │\n│   A │   B │\n│   1 │   2 │\n└─────┴─────┘\n\n","category":"page"},{"location":"man/table_exploring/#Exploring-your-table","page":"Exploring your table","title":"Exploring your table","text":"","category":"section"},{"location":"man/table_exploring/","page":"Exploring your table","title":"Exploring your table","text":"TODO","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"CurrentModule = Cleaner","category":"page"},{"location":"lib/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"lib/types/#CleanTable-type-design","page":"Types","title":"CleanTable type design","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"CleanTable is the type where all Cleaner.jl functions operate. For example, when you call polish_names(table) internally a CleanTable (ct) with copied columns based in the table passed is being created and polish_names!(ct) is called to return the desired result.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"By default the constructor that builds a CleanTable from a table copies the columns but this behavior can be bypassed by passing the argument copycols=false e.g. CleanTable(table; copycols=false).","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"It is only possible to change column names from a CleanTable directly, adding/removing rows or columns without using Cleaner.jl functions is not supported and heavily discouraged. Please use other packages that support the Tables.jl interface such as DataFrames.jl for those needs.","category":"page"},{"location":"lib/types/#Type-specification","page":"Types","title":"Type specification","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"CleanTable","category":"page"},{"location":"lib/types/#Cleaner.CleanTable","page":"Types","title":"Cleaner.CleanTable","text":"CleanTable <: Tables.AbstractColumns\n\nA Tables.jl implementation that stores column names and columns for Cleaner.jl internal use.\n\nThe default behavior of this type is to try to copy the columns of the original Tables implementation a.k.a: the source, but the user can call the second constructor specifiying copycols=false to override this behavior and try to use the original columns directly. If the source column type is not mutable, it might end up in errors.\n\nConstructors\n\nCleanTable(names::Vector{Symbol}, cols; copycols::Bool=false)\nCleanTable(table; copycols::Bool=true)\nCleanTable(table::CleanTable; copycols::Bool=true)\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Cleaner","category":"page"},{"location":"#Cleaner","page":"Home","title":"Cleaner","text":"","category":"section"},{"location":"#A-toolbox-of-simple-solutions-for-common-data-cleaning-problems.","page":"Home","title":"A toolbox of simple solutions for common data cleaning problems.","text":"","category":"section"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"#With-Cleaner.jl-you-will-be-able-to:","page":"Home","title":"With Cleaner.jl you will be able to:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Format column names to make them unique and fit snake_case or camelCase style.\nRemove rows and columns with different kinds of empty values.","category":"page"},{"location":"","page":"Home","title":"Home","text":"e.g: missing, \"\", \"NA\", \"None\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Delete columns filled with just a constant value.\nDelete entire rows where at least one missing value was found.","category":"page"},{"location":"","page":"Home","title":"Home","text":"e.g: missing, \"\", \"NA\", \"None\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Use a row as the names of the columns.\nAdd a row index for your table.\nMinimize the amount of element types for each column without making the column of type Any.\nAutomatically use multiple threads if your data is big enough (and you are running Julia with more than 1 thread).\nRematerialize your original source Tables.jl type, as CleanTable implements the Tables.jl interface too.\nApply Cleaner transformations on your original table implementation and have the resulting table be of the same type as the original.","category":"page"},{"location":"#To-keep-in-mind","page":"Home","title":"To keep in mind","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All non mutating functions (those ending without a !) recieve a table as argument and return a CleanTable. All mutating functions (those ending with a !) recieve a CleanTable and return a CleanTable. All returning original type function variants (those ending with ROT) recieve a table as argument and return a table of the same type of the original.","category":"page"},{"location":"","page":"Home","title":"Home","text":"So you can start your workflow with a non mutating function and continue using mutating ones. E.g.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using DataFrames: DataFrame\n\njulia> using Cleaner\n\njulia> df = DataFrame(\" some bad Name\" => [missing, missing, missing], \"Another_weird name \" => [1, 2, 3])\n3×2 DataFrame\n Row │  some bad Name  Another_weird name\n     │ Missing         Int64\n─────┼─────────────────────────────────────\n   1 │        missing                    1\n   2 │        missing                    2\n   3 │        missing                    3\n\njulia> df |> polish_names |> compact_columns!\n┌────────────────────┐\n│ another_weird_name │\n│              Int64 │\n├────────────────────┤\n│                  1 │\n│                  2 │\n│                  3 │\n└────────────────────┘\n\n","category":"page"},{"location":"#Acknowledgement","page":"Home","title":"Acknowledgement","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Inspired by janitor from the R ecosystem.","category":"page"},{"location":"man/dirt_removal/#Getting-the-dirt-out","page":"Getting the dirt out","title":"Getting the dirt out","text":"","category":"section"},{"location":"man/dirt_removal/#No-value,-not-kept","page":"Getting the dirt out","title":"No value, not kept","text":"","category":"section"},{"location":"man/dirt_removal/","page":"Getting the dirt out","title":"Getting the dirt out","text":"Adhering to this philosophy, usually we don't want to keep rows or columns filled just with empty values in our table. Empty values can quickly become a big problem to handle when they come in different standards such as Julia's missing, Python's None, R's NA and a diversity of common strings like \"\", ' ', etc.","category":"page"},{"location":"man/dirt_removal/","page":"Getting the dirt out","title":"Getting the dirt out","text":"As an easy way to handle this common problems we got the compact functions, being them compact_table, compact_columns and compact_rows with their mutating in-place and ROT variants i.e. compact_table!, compact_table_ROT et al.","category":"page"},{"location":"man/dirt_removal/","page":"Getting the dirt out","title":"Getting the dirt out","text":"They all recieve a table as first argument and an optional keyword argument empty_values where you can pass a vector of what you consider being empty values present in your table. By default Julia's missing is always considered an empty value.","category":"page"},{"location":"man/dirt_removal/","page":"Getting the dirt out","title":"Getting the dirt out","text":"julia> using Cleaner\n\njulia> ct = CleanTable([:A, :B, :C], [[missing, missing, missing], [1, missing, 3], [\"x\", \"\", \"z\"]])\n┌─────────┬─────────┬────────┐\n│       A │       B │      C │\n│ Missing │  Int64? │ String │\n├─────────┼─────────┼────────┤\n│ missing │       1 │      x │\n│ missing │ missing │        │\n│ missing │       3 │      z │\n└─────────┴─────────┴────────┘\n\n\njulia> compact_columns(ct)\n┌─────────┬────────┐\n│       B │      C │\n│  Int64? │ String │\n├─────────┼────────┤\n│       1 │      x │\n│ missing │        │\n│       3 │      z │\n└─────────┴────────┘\n\n\njulia> compact_rows(ct; empty_values=[\"\"])\n┌─────────┬────────┬────────┐\n│       A │      B │      C │\n│ Missing │ Int64? │ String │\n├─────────┼────────┼────────┤\n│ missing │      1 │      x │\n│ missing │      3 │      z │\n└─────────┴────────┴────────┘\n\n\njulia> compact_table(ct; empty_values=[\"\"])\n┌────────┬────────┐\n│      B │      C │\n│ Int64? │ String │\n├────────┼────────┤\n│      1 │      x │\n│      3 │      z │\n└────────┴────────┘\n\n","category":"page"},{"location":"man/dirt_removal/","page":"Getting the dirt out","title":"Getting the dirt out","text":"You might also feel that columns filled with just a constant value are not adding any value to your table and may prefer to remove them, for those cases we got the delete_const_columns, delete_const_columns! and delete_const_columns_ROT functions.","category":"page"},{"location":"man/dirt_removal/","page":"Getting the dirt out","title":"Getting the dirt out","text":"julia> ct = CleanTable([:A, :B, :C], [[4, 5, 6], [1, 1, 1], String[\"7\", \"8\", \"9\"]])\n┌───────┬───────┬────────┐\n│     A │     B │      C │\n│ Int64 │ Int64 │ String │\n├───────┼───────┼────────┤\n│     4 │     1 │      7 │\n│     5 │     1 │      8 │\n│     6 │     1 │      9 │\n└───────┴───────┴────────┘\n\n\njulia> delete_const_columns(ct)\n┌───────┬────────┐\n│     A │      C │\n│ Int64 │ String │\n├───────┼────────┤\n│     4 │      7 │\n│     5 │      8 │\n│     6 │      9 │\n└───────┴────────┘\n\n","category":"page"}]
}
