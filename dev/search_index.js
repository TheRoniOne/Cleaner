var documenterSearchIndex = {"docs":
[{"location":"lib/functions/","page":"Functions","title":"Functions","text":"CurrentModule = Cleaner","category":"page"},{"location":"lib/functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"lib/functions/#Multi-threading-support","page":"Functions","title":"Multi-threading support","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"The following functions will try to use multiple threads if possible when there are at least 2 columns and 1 million rows:","category":"page"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"CleanTable constructor when copycols=true\nAll compact functions\ndelete_const_columns and delete_const_columns!\nreinfer_schema and reinfer_schema!","category":"page"},{"location":"lib/functions/#Index","page":"Functions","title":"Index","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"lib/functions/#Summarize-information","page":"Functions","title":"Summarize information","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"size","category":"page"},{"location":"lib/functions/#Cleaner.size","page":"Functions","title":"Cleaner.size","text":"size(table::CleanTable)\n\nReturns a tuple containing the number of rows and columns of the given table.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Working-with-column-names","page":"Functions","title":"Working with column names","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"generate_polished_names\npolish_names\npolish_names!\nrow_as_names\nrow_as_names!","category":"page"},{"location":"lib/functions/#Cleaner.generate_polished_names","page":"Functions","title":"Cleaner.generate_polished_names","text":"generate_polished_names(names; style::Symbol=:snake_case)\n\nReturn a vector of symbols containing new names that are unique and formated using the style selected.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.polish_names","page":"Functions","title":"Cleaner.polish_names","text":"polish_names(table; style=:snake_case)\n\nCreate and return a CleanTable with copied columns having column names replaced to be unique and formated using the style selected.\n\nStyles\n\nsnake_case\ncamelCase\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.polish_names!","page":"Functions","title":"Cleaner.polish_names!","text":"polish_names!(table::CleanTable; style::Symbol=:snake_case)\n\nReturn a CleanTable where column names have been replaced to be unique and formated using the style selected.\n\nStyles\n\nsnake_case\ncamelCase\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.row_as_names","page":"Functions","title":"Cleaner.row_as_names","text":"row_as_names(table, i::Int; remove::Bool=false)\n\nCreates a CleanTable with copied columns and renames the table using row i as new names and removes in-place all the rows above row i if remove=true.\n\nDefault behavior is to remove rows above row i.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.row_as_names!","page":"Functions","title":"Cleaner.row_as_names!","text":"row_as_names!(table::CleanTable, i::Int; remove::Bool=true)\n\nRenames the table using row i as new names and removes in-place all the rows above row i if remove=true.\n\nDefault behavior is to remove rows above row i.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Row/Column-removal","page":"Functions","title":"Row/Column removal","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"compact_columns\ncompact_columns!\ncompact_rows\ncompact_rows!\ncompact_table\ncompact_table!\ndelete_const_columns\ndelete_const_columns!","category":"page"},{"location":"lib/functions/#Cleaner.compact_columns","page":"Functions","title":"Cleaner.compact_columns","text":"compact_columns(table; empty_values::Vector=[])\n\nCreates a CleanTable with copied columns and removes from it all columns filled entirely by missing and empty_values.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.compact_columns!","page":"Functions","title":"Cleaner.compact_columns!","text":"compact_columns!(table::CleanTable; empty_values::Vector=[])\n\nRemoves in-place from a CleanTable all columns filled entirely by missing and empty_values.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.compact_rows","page":"Functions","title":"Cleaner.compact_rows","text":"compact_rows(table; empty_values::Vector=[])\n\nCreates a CleanTable with copied columns and removes from it all rows filled entirely by missing and empty_values.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.compact_rows!","page":"Functions","title":"Cleaner.compact_rows!","text":"compact_rows!(table::CleanTable; empty_values::Vector=[])\n\nRemoves in-place from a CleanTable all rows filled entirely by missing and empty_values.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.compact_table","page":"Functions","title":"Cleaner.compact_table","text":"compact_table(table; empty_values::Vector=[])\n\nCreates a CleanTable with copied columns and removes from it all rows and columns filled entirely by missing and empty_values.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.compact_table!","page":"Functions","title":"Cleaner.compact_table!","text":"compact_table!(table::CleanTable; empty_values::Vector=[])\n\nRemoves in-place from a CleanTable all rows and columns filled entirely by missing and  empty_values.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.delete_const_columns","page":"Functions","title":"Cleaner.delete_const_columns","text":"delete_const_columns(table)\n\nCreates a CleanTable with copied columns and removes each column filled with just a constant value.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.delete_const_columns!","page":"Functions","title":"Cleaner.delete_const_columns!","text":"delete_const_columns!(table::CleanTable)\n\nRemoves in-place from a CleanTable each column filled with just a constant value.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Modifiying-table-schema","page":"Functions","title":"Modifiying table schema","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"reinfer_schema\nreinfer_schema!","category":"page"},{"location":"lib/functions/#Cleaner.reinfer_schema","page":"Functions","title":"Cleaner.reinfer_schema","text":"reinfer_schema(table; max_types::Int=3)\n\nCreates a CleanTable with copied columns and tries to minimize the amount of element types for each column without making the column type Any.\n\nFor this, will try to make the column of type Union with up to maxtypes and internally use ```Base.promotetypejoin``` on all numeric types. If not possible, leaves the column as-is.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Cleaner.reinfer_schema!","page":"Functions","title":"Cleaner.reinfer_schema!","text":"reinfer_schema!(table::CleanTable; max_types::Int=3)\n\nTries to minimize the amount of element types for each column without making the column type Any.\n\nFor this, will try to make the column of type Union with up to maxtypes and internally use ```Base.promotetypejoin``` on all numeric types. If not possible, leaves the column as-is.\n\n\n\n\n\n","category":"function"},{"location":"man/first_steps/#First-steps","page":"First steps","title":"First steps","text":"","category":"section"},{"location":"man/first_steps/#Installation","page":"First steps","title":"Installation","text":"","category":"section"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"Installing the latest stable version of Cleaner is as simple as using:","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"import Pkg\nPkg.add(\"Cleaner\")","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"After installation has finished, you just need to call using Cleaner to get all Cleaner functionalities in your current namespace.","category":"page"},{"location":"man/first_steps/#About-the-CleanTable-type","page":"First steps","title":"About the CleanTable type","text":"","category":"section"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"A CleanTable is meant to represent data in a tabular format, being column based by design, while also being the type where all Cleaner functions do their work.","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"It implements the Tables.jl interface and the constructor can create a CleanTable from any Tables.jl implementation.","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"julia> using DataFrames\n\njulia> df = DataFrame(A = Any[1, 2, 3, 4], B = Any[\"M\", \"F\", \"F\", \"M\"])\n4×2 DataFrame\n Row │ A    B\n     │ Any  Any\n─────┼──────────\n   1 │ 1    M\n   2 │ 2    F\n   3 │ 3    F\n   4 │ 4    M\n\njulia> using Cleaner\n\njulia> ct = CleanTable(df)\n┌─────┬─────┐\n│   A │   B │\n│ Any │ Any │\n├─────┼─────┤\n│   1 │   M │\n│   2 │   F │\n│   3 │   F │\n│   4 │   M │\n└─────┴─────┘\n\n","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"If the original Tables.jl implementation (source) you were using supports constructing the source type from any Tables.jl implementation, getting back to using an object of your source type is as easy as calling its constructor after you have finished working with Cleaner.","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"julia> reinfer_schema!(ct)\n┌───────┬────────┐\n│     A │      B │\n│ Int64 │ String │\n├───────┼────────┤\n│     1 │      M │\n│     2 │      F │\n│     3 │      F │\n│     4 │      M │\n└───────┴────────┘\n\n\njulia> DataFrame(ct)\n4×2 DataFrame\n Row │ A      B\n     │ Int64  String\n─────┼───────────────\n   1 │     1  M\n   2 │     2  F\n   3 │     3  F\n   4 │     4  M\n","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"All Cleaner functions support piping too so the code above could be rewritten as this:","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"julia> df |> CleanTable |> reinfer_schema! |> DataFrame\n4×2 DataFrame\n Row │ A      B\n     │ Int64  String\n─────┼───────────────\n   1 │     1  M\n   2 │     2  F\n   3 │     3  F\n   4 │     4  M\n","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"By default the CleanTable constructor when called with a table as only argument will copy the columns instead of using directly the source columns. This behavior can be overwritten by explicitly passing the copycols=false keyword argument.","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"julia> ct = CleanTable(df)\n┌─────┬─────┐\n│   A │   B │\n│ Any │ Any │\n├─────┼─────┤\n│   1 │   M │\n│   2 │   F │\n│   3 │   F │\n│   4 │   M │\n└─────┴─────┘\n\n\njulia> ct.A[1] = 5\n5\n\njulia> ct\n┌─────┬─────┐\n│   A │   B │\n│ Any │ Any │\n├─────┼─────┤\n│   5 │   M │\n│   2 │   F │\n│   3 │   F │\n│   4 │   M │\n└─────┴─────┘\n\n\njulia> df\n4×2 DataFrame\n Row │ A    B\n     │ Any  Any\n─────┼──────────\n   1 │ 1    M\n   2 │ 2    F\n   3 │ 3    F\n   4 │ 4    M\n\njulia> ct = CleanTable(df; copycols=false)\n┌─────┬─────┐\n│   A │   B │\n│ Any │ Any │\n├─────┼─────┤\n│   1 │   M │\n│   2 │   F │\n│   3 │   F │\n│   4 │   M │\n└─────┴─────┘\n\n\njulia> ct.A[1] = 5;\n\njulia> ct\n┌─────┬─────┐\n│   A │   B │\n│ Any │ Any │\n├─────┼─────┤\n│   5 │   M │\n│   2 │   F │\n│   3 │   F │\n│   4 │   M │\n└─────┴─────┘\n\n\njulia> df\n4×2 DataFrame\n Row │ A    B\n     │ Any  Any\n─────┼──────────\n   1 │ 5    M\n   2 │ 2    F\n   3 │ 3    F\n   4 │ 4    M\n","category":"page"},{"location":"man/first_steps/#Accessing-columns","page":"First steps","title":"Accessing columns","text":"","category":"section"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"If you want to access an specific column, CleanTable supports access by column index and column name.","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"julia> ct = CleanTable([:A, :B], [[1, 2, 3, 4], [\"M\", \"F\", \"F\", \"M\"]])\n┌───────┬────────┐\n│     A │      B │\n│ Int64 │ String │\n├───────┼────────┤\n│     1 │      M │\n│     2 │      F │\n│     3 │      F │\n│     4 │      M │\n└───────┴────────┘\n\n\njulia> ct.A\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> ct[1]\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"As the result of accessing a column in a CleanTable is the column itself, if you want to reasign values in a column you can just modify the accessed result.","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"E.g:","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"julia> ct.A = [5, 6, 7, 8]\n4-element Vector{Int64}:\n 5\n 6\n 7\n 8\n\njulia> ct\n┌───────┬────────┐\n│     A │      B │\n│ Int64 │ String │\n├───────┼────────┤\n│     5 │      M │\n│     6 │      F │\n│     7 │      F │\n│     8 │      M │\n└───────┴────────┘\n\n","category":"page"},{"location":"man/first_steps/","page":"First steps","title":"First steps","text":"warning: Warning\nAdding/removing rows or columns without using Cleaner.jl  functions is not supported and heavily discouraged. Please refer to other packages such as  DataFrames.jl for those needs.","category":"page"},{"location":"man/name_changing/#A-name-changing-help","page":"A name-changing help","title":"A name-changing help","text":"","category":"section"},{"location":"man/name_changing/#Column-names-polishing","page":"A name-changing help","title":"Column names polishing","text":"","category":"section"},{"location":"man/name_changing/","page":"A name-changing help","title":"A name-changing help","text":"Having repated column names, names with spaces in them, names where spaces are padding the beginning or the end, names with inconsistent formating, etc can certainly become a trouble when trying to reference a certain column during your workflow.","category":"page"},{"location":"man/name_changing/","page":"A name-changing help","title":"A name-changing help","text":"To tackle this problems directly, we have the functions polish_names and polish_names! used as follows:","category":"page"},{"location":"man/name_changing/","page":"A name-changing help","title":"A name-changing help","text":"julia> using Cleaner\n\njulia> ct = CleanTable([Symbol(\" Horrible name 1\"), Symbol(\"another_bad Name  \")], [[1], [2]])\n┌──────────────────┬────────────────────┐\n│  Horrible name 1 │ another_bad Name   │\n│            Int64 │              Int64 │\n├──────────────────┼────────────────────┤\n│                1 │                  2 │\n└──────────────────┴────────────────────┘\n\n\njulia> polish_names(ct)\n┌─────────────────┬──────────────────┐\n│ horrible_name_1 │ another_bad_name │\n│           Int64 │            Int64 │\n├─────────────────┼──────────────────┤\n│               1 │                2 │\n└─────────────────┴──────────────────┘\n\n\njulia> polish_names(ct; style=:camelCase)\n┌───────────────┬────────────────┐\n│ horribleName1 │ anotherBadName │\n│         Int64 │          Int64 │\n├───────────────┼────────────────┤\n│             1 │              2 │\n└───────────────┴────────────────┘\n\n","category":"page"},{"location":"man/name_changing/","page":"A name-changing help","title":"A name-changing help","text":"note: Note\nCurrently the only available styles are :snake_case and :camelCase.  The default style is :snake_case.","category":"page"},{"location":"man/name_changing/","page":"A name-changing help","title":"A name-changing help","text":"Internally polish_names and polish_names! both call the generate_polished_names function, so if you just need to generate better names for your table, you could call it as follows and manually rename your table.","category":"page"},{"location":"man/name_changing/","page":"A name-changing help","title":"A name-changing help","text":"julia> generate_polished_names([\"  _aName with_lotsOfProblems\", \"  _aName with_lotsOfProblems\"])\n2-element Vector{Symbol}:\n :a_name_with_lots_of_problems\n :a_name_with_lots_of_problems_1\n\njulia> generate_polished_names([\"  _aName with_lotsOfProblems\", \"  _aName with_lotsOfProblems\"]; style=:camelCase)\n2-element Vector{Symbol}:\n :aNameWithLotsOfProblems\n :aNameWithLotsOfProblems_1\n","category":"page"},{"location":"man/name_changing/#Making-a-row-be-the-column-names","page":"A name-changing help","title":"Making a row be the column names","text":"","category":"section"},{"location":"man/name_changing/","page":"A name-changing help","title":"A name-changing help","text":"When working with messy data you might end up having the row names being the second or third row of the table you have loaded. For this cases you can use the row_as_names and row_as_names! functions.","category":"page"},{"location":"man/name_changing/","page":"A name-changing help","title":"A name-changing help","text":"julia> ct = CleanTable([Symbol(\" \"), Symbol(\" \")], [[\" \", \"A\", 1], [\" \", \"B\", 2]])\n┌─────┬─────┐\n│     │     │\n│ Any │ Any │\n├─────┼─────┤\n│     │     │\n│   A │   A │\n│   1 │   1 │\n└─────┴─────┘\n\n\njulia> row_as_names(ct, 2)\n┌─────┬─────┐\n│   A │   B │\n│ Any │ Any │\n├─────┼─────┤\n│   1 │   2 │\n└─────┴─────┘\n\n\njulia> row_as_names(ct, 2; remove=false)\n┌─────┬─────┐\n│   A │   B │\n│ Any │ Any │\n├─────┼─────┤\n│     │     │\n│   A │   B │\n│   1 │   2 │\n└─────┴─────┘\n\n","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"CurrentModule = Cleaner","category":"page"},{"location":"lib/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"lib/types/#CleanTable-type-design","page":"Types","title":"CleanTable type design","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"CleanTable is the type where all Cleaner.jl functions operate. For example, when you call polish_names(table) internally a CleanTable (ct) with copied columns based in the table passed is being created and polish_names!(ct) is called to return the desired result.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"By default the constructor that builds a CleanTable from a table copies the columns but this behavior can be bypassed by passing the argument copycols=false e.g. CleanTable(table; copycols=false).","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"It is only possible to change column names from a CleanTable directly, adding/removing rows or columns without using Cleaner.jl functions is not supported and heavily discouraged. Please use other packages that support the Tables.jl interface such as DataFrames.jl for those needs.","category":"page"},{"location":"lib/types/#Type-specification","page":"Types","title":"Type specification","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"CleanTable","category":"page"},{"location":"lib/types/#Cleaner.CleanTable","page":"Types","title":"Cleaner.CleanTable","text":"CleanTable <: Tables.AbstractColumns\n\nA Tables.jl implementation that stores column names and columns for Cleaner.jl internal use.\n\nThe default behavior of this type is to try to copy the columns of the original Tables implementation a.k.a: the source, but the user can call the second constructor specifiying copycols=false to override this behavior and try to use the original columns directly, but if the source column type is not mutable, it will end up in errors.\n\nConstructors\n\nCleanTable(names::Vector{Symbol}, cols; copycols::Bool=false)\nCleanTable(table; copycols::Bool=true)\nCleanTable(table::CleanTable; copycols::Bool=true)\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Cleaner","category":"page"},{"location":"#Cleaner","page":"Home","title":"Cleaner","text":"","category":"section"},{"location":"#A-toolbox-of-simple-solutions-for-common-data-cleaning-problems.","page":"Home","title":"A toolbox of simple solutions for common data cleaning problems.","text":"","category":"section"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"#With-Cleaner.jl-you-will-be-able-to:","page":"Home","title":"With Cleaner.jl you will be able to:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Format column names to make them unique and fit snake_case or camelCase style.\nRemove rows and columns with different kinds of empty values. e.g: missing, \"\", \"NA\", \"None\"\nDelete columns filled with just a constant value.\nUse a row as the names of the columns.\nMinimize the amount of element types for each column without making the column of type Any.\nAutomatically use multiple threads if your data is big enough (and you are running Julia with more than 1 thread).\nRematerialize your original source Tables.jl type, as CleanTable implements the Tables.jl interface too.","category":"page"},{"location":"#Acknowledgement","page":"Home","title":"Acknowledgement","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Inspired by janitor from the R ecosystem.","category":"page"},{"location":"man/dirt_removal/#Getting-the-dirt-out","page":"Getting the dirt out","title":"Getting the dirt out","text":"","category":"section"},{"location":"man/dirt_removal/#No-value,-not-kept","page":"Getting the dirt out","title":"No value, not kept","text":"","category":"section"},{"location":"man/dirt_removal/","page":"Getting the dirt out","title":"Getting the dirt out","text":"Adhering to this philosophy, usually we don't want to keep rows or columns filled just with empty values in our table. Empty values can quickly become a big problem to handle when they come in different standards such as Julia's missing, Python's None, R's NA and a diversity of common strings like \"\", ' ', etc.","category":"page"},{"location":"man/dirt_removal/","page":"Getting the dirt out","title":"Getting the dirt out","text":"As an easy way to handle this common problems we got the compact functions, being them  compact_table, compact_columns and compact_rows with their mutating in-place variants i.e. compact_table! et al.","category":"page"},{"location":"man/dirt_removal/","page":"Getting the dirt out","title":"Getting the dirt out","text":"They all recieve a table as first argument and an optional keyword argument empty_values where you can pass a vector of what you consider being empty values present in your table. By default Julia's missings are always being considered empty values.","category":"page"},{"location":"man/dirt_removal/","page":"Getting the dirt out","title":"Getting the dirt out","text":"julia> using Cleaner\n\njulia> ct = CleanTable([:A, :B, :C], [[missing, missing, missing], [1, missing, 3], [\"x\", \"\", \"z\"]])\n┌─────────┬─────────┬────────┐\n│       A │       B │      C │\n│ Missing │  Int64? │ String │\n├─────────┼─────────┼────────┤\n│ missing │       1 │      x │\n│ missing │ missing │        │\n│ missing │       3 │      z │\n└─────────┴─────────┴────────┘\n\n\njulia> compact_columns(ct)\n┌─────────┬────────┐\n│       B │      C │\n│  Int64? │ String │\n├─────────┼────────┤\n│       1 │      x │\n│ missing │        │\n│       3 │      z │\n└─────────┴────────┘\n\n\njulia> compact_rows(ct; empty_values=[\"\"])\n┌─────────┬────────┬────────┐\n│       A │      B │      C │\n│ Missing │ Int64? │ String │\n├─────────┼────────┼────────┤\n│ missing │      1 │      x │\n│ missing │      3 │      z │\n└─────────┴────────┴────────┘\n\n\njulia> compact_table(ct; empty_values=[\"\"])\n┌────────┬────────┐\n│      B │      C │\n│ Int64? │ String │\n├────────┼────────┤\n│      1 │      x │\n│      3 │      z │\n└────────┴────────┘\n\n","category":"page"},{"location":"man/dirt_removal/#Better-have-something-rather-than-Any","page":"Getting the dirt out","title":"Better have something rather than Any","text":"","category":"section"},{"location":"man/dirt_removal/","page":"Getting the dirt out","title":"Getting the dirt out","text":"If you have worked with data in Julia before, you might have ended up with a column of element type Any more than once. This usually happens when your column has a mix of different types that can't be promoted or converted to one and other.","category":"page"},{"location":"man/dirt_removal/","page":"Getting the dirt out","title":"Getting the dirt out","text":"Now, the main problem is that element type Any doesn't gives us any relevant information about what is being stored in our column.","category":"page"},{"location":"man/dirt_removal/","page":"Getting the dirt out","title":"Getting the dirt out","text":"julia> [1, 2.0]\n2-element Vector{Float64}:\n 1.0\n 2.0\n\njulia> [\"1\", 2.0]\n2-element Vector{Any}:\n  \"1\"\n 2.0\n","category":"page"},{"location":"man/dirt_removal/","page":"Getting the dirt out","title":"Getting the dirt out","text":"To solve this problem we have the reinfer_schema and reinfer_schema! functions that will try to make the column of type Union with, by default, up to 3 types stored in Union while also internally using Base.promote_typejoin on numeric types to reduce the final amount of numeric types.","category":"page"},{"location":"man/dirt_removal/","page":"Getting the dirt out","title":"Getting the dirt out","text":"The optional keyword argument max_types can be used to change the maximum amount of types in Union, as if there would be more than max_types on the final Union, this functions just will give up and let the column stay with element type Any.","category":"page"},{"location":"man/dirt_removal/","page":"Getting the dirt out","title":"Getting the dirt out","text":"julia> ct = CleanTable([:A, :B, :C], [[1, 2, 3, 4], [5, missing, \"z\", 2.0], [\"6\", \"7\", \"8\", \"9\"]])\n┌─────┬─────────┬─────┐\n│   A │       B │   C │\n│ Any │     Any │ Any │\n├─────┼─────────┼─────┤\n│   1 │       5 │   6 │\n│   2 │ missing │   7 │\n│   3 │       z │   8 │\n│   4 │     2.0 │   9 │\n└─────┴─────────┴─────┘\n\n\njulia> reinfer_schema(ct)\n┌───────┬──────────────────┬────────┐\n│     A │                B │      C │\n│ Int64 │ U{Real, String}? │ String │\n├───────┼──────────────────┼────────┤\n│     1 │                5 │      6 │\n│     2 │          missing │      7 │\n│     3 │                z │      8 │\n│     4 │              2.0 │      9 │\n└───────┴──────────────────┴────────┘\n\n\njulia> reinfer_schema(ct; max_types=2)\n┌───────┬─────────┬────────┐\n│     A │       B │      C │\n│ Int64 │     Any │ String │\n├───────┼─────────┼────────┤\n│     1 │       5 │      6 │\n│     2 │ missing │      7 │\n│     3 │       z │      8 │\n│     4 │     2.0 │      9 │\n└───────┴─────────┴────────┘\n\n","category":"page"}]
}
